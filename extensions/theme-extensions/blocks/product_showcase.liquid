{% comment %}
  Product Showcase Theme App Extension Block
  Two-column layout: Left - Product image, Right - Text content
{% endcomment %}

<div class="product-showcase-block" {{ block.shopify_attributes }}>
  <style>
    .product-showcase-block {
      display: flex;
      align-items: center;
      gap: 2rem;
      padding: 2rem;
      margin: 1rem 0;
      max-width: 100%;
    }
    
    .product-showcase-left {
      flex: 1;
      min-width: 0;
    }
    
    .product-showcase-right {
      flex: 1;
      min-width: 0;
    }
    
    .product-image {
      width: 100%;
      height: auto;
      border-radius: 8px;
      object-fit: cover;
      max-height: 400px;
    }
    
    .placeholder-image {
      width: 100%;
      height: 300px;
      background: #f5f5f5;
      border: 2px dashed #ccc;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-size: 1rem;
      text-align: center;
    }
    
    .model-container {
      position: relative;
      width: 100%;
      height: 400px;
      border-radius: 8px;
      overflow: hidden;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    }
    
    .model-canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 8px;
    }
    
    .loading-indicator {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(5px);
      color: #333;
      font-size: 14px;
      z-index: 10;
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #333;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .fallback-image {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .content-title {
      font-size: {{ block.settings.title_size }}px;
      font-weight: bold;
      color: {{ block.settings.title_color }};
      margin: 0 0 1rem 0;
      line-height: 1.2;
    }
    
    .content-subtitle {
      font-size: {{ block.settings.subtitle_size }}px;
      color: {{ block.settings.subtitle_color }};
      margin: 0 0 1.5rem 0;
      line-height: 1.4;
      font-weight: 500;
    }
    
    .content-paragraph {
      font-size: {{ block.settings.text_size }}px;
      color: {{ block.settings.text_color }};
      line-height: 1.6;
      margin: 0;
    }
    
    @media (max-width: 768px) {
      .product-showcase-block {
        flex-direction: column;
        gap: 1.5rem;
        padding: 1.5rem;
      }
      
      .product-showcase-left,
      .product-showcase-right {
        flex: none;
        width: 100%;
      }
    }
  </style>
  
  <div class="product-showcase-left">
    {% if block.settings.product != blank %}
      {% assign product = all_products[block.settings.product] %}
      
      {% if product.featured_image and block.settings.enable_3d %}
        <!-- 3D Image Container -->
        <div id="model-container-{{ block.id }}" class="model-container">
          <canvas id="model-canvas-{{ block.id }}" class="model-canvas"></canvas>
          <div id="loading-{{ block.id }}" class="loading-indicator">
            <div class="spinner"></div>
            <span>Loading 3D View...</span>
          </div>
        </div>
      {% elsif product.featured_image %}
        <img 
          src="{{ product.featured_image | image_url: width: 600 }}" 
          alt="{{ product.featured_image.alt | default: product.title }}"
          class="product-image"
          width="600"
          height="400"
          loading="lazy"
        />
      {% else %}
        <div class="placeholder-image">
          <span>{{ product.title }}<br>No image available</span>
        </div>
      {% endif %}
    {% else %}
      <div class="placeholder-image">
        <span>Select a product to display</span>
      </div>
    {% endif %}
  </div>
  
  <div class="product-showcase-right">
    {% if block.settings.title != blank %}
      <h2 class="content-title">{{ block.settings.title }}</h2>
    {% endif %}
    
    {% if block.settings.subtitle != blank %}
      <h3 class="content-subtitle">{{ block.settings.subtitle }}</h3>
    {% endif %}
    
    {% if block.settings.paragraph != blank %}
      <p class="content-paragraph">{{ block.settings.paragraph }}</p>
    {% endif %}
  </div>
</div>

<!-- Three.js CDN and Advanced Libraries -->
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.20.0/dist/tf.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/depth-estimation@0.0.6/dist/depth-estimation.min.js"></script>

<script>
// Global error handler for 3D debugging
window.addEventListener('error', function(e) {
  if (e.message.includes('THREE') || e.filename.includes('three')) {
    console.error('üö® THREE.js Error:', {
      message: e.message,
      filename: e.filename,
      lineno: e.lineno,
      colno: e.colno,
      error: e.error
    });
  }
});

// Log browser support info
console.log('üåê Browser Info:', {
  userAgent: navigator.userAgent,
  webGL: !!window.WebGLRenderingContext,
  webGL2: !!window.WebGL2RenderingContext,
  devicePixelRatio: window.devicePixelRatio
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  console.log('üöÄ DOM Content Loaded - Product Showcase Block {{ block.id }}');
  console.log('üì¶ Block settings:', {
    enable_3d: {{ block.settings.enable_3d | default: false }},
    rotation_speed: {{ block.settings.rotation_speed | default: 1 }},
    model_scale: {{ block.settings.model_scale | default: 1.5 }},
    camera_distance: {{ block.settings.camera_distance | default: 3 }},
    camera_height: {{ block.settings.camera_height | default: 0 }},
    enable_bobbing: {{ block.settings.enable_bobbing | default: false }}
  });
  
  {% if block.settings.enable_3d %}
    {% if block.settings.product != blank %}
      {% assign product = all_products[block.settings.product] %}
      {% if product.featured_image %}
        console.log('‚úÖ 3D enabled with product image, initializing 3D view...');
        console.log('üñºÔ∏è Image URL:', '{{ product.featured_image | image_url: width: 600 }}');
        initializeModel{{ block.id | replace: '-', '_' }}();
      {% else %}
        console.log('‚ùå No product image available for 3D view');
      {% endif %}
    {% else %}
      console.log('‚ùå No product selected for 3D view');
    {% endif %}
  {% else %}
    console.log('‚ùå 3D view disabled, showing regular image');
  {% endif %}
});

{% if block.settings.enable_3d %}
function initializeModel{{ block.id | replace: '-', '_' }}() {
  console.log('üéØ Starting 3D image initialization for block {{ block.id }}');
  
  const container = document.getElementById('model-container-{{ block.id }}');
  const canvas = document.getElementById('model-canvas-{{ block.id }}');
  const loading = document.getElementById('loading-{{ block.id }}');
  
  console.log('üîç DOM Elements found:', {
    container: !!container,
    canvas: !!canvas,
    loading: !!loading
  });
  
  if (!container || !canvas) {
    console.error('‚ùå Required DOM elements not found!', {
      container: container,
      canvas: canvas
    });
    return;
  }
  
  console.log('üìè Container dimensions:', {
    width: container.offsetWidth,
    height: container.offsetHeight
  });
  
  // Check if Three.js is loaded
  if (typeof THREE === 'undefined') {
    console.error('‚ùå THREE.js not loaded!');
    return;
  }
  console.log('‚úÖ THREE.js loaded:', THREE.REVISION);
  
  // Scene setup
  console.log('üé¨ Creating Three.js scene...');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf5f7fa);
  
  const camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, 1000);
  
  console.log('üñ•Ô∏è Setting up WebGL renderer...');
  const renderer = new THREE.WebGLRenderer({ 
    canvas: canvas, 
    antialias: true, 
    alpha: true 
  });
  
  renderer.setSize(container.offsetWidth, container.offsetHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.outputEncoding = THREE.sRGBEncoding;
  
  console.log('‚úÖ Renderer setup complete:', {
    size: [container.offsetWidth, container.offsetHeight],
    pixelRatio: renderer.getPixelRatio()
  });
  
  // Lighting setup
  console.log('üí° Setting up lighting...');
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(5, 5, 5);
  scene.add(directionalLight);
  console.log('‚úÖ Lighting setup complete');
  
  // Create realistic 3D object with AI depth estimation
  console.log('üñºÔ∏è Creating realistic 3D object from product image...');
  const imageUrl = '{{ product.featured_image | image_url: width: 600 }}';
  
  // Wait for TensorFlow and depth estimation models to load
  waitForAIModels(function() {
    console.log('ü§ñ AI models loaded, processing image...');
    
    // Process image for realistic 3D conversion
    createRealistic3DObject(imageUrl, function(mesh) {
      console.log('‚úÖ Realistic 3D object created!');
      
      // Store the mesh
      window['model_{{ block.id | replace: "-", "_" }}'] = mesh;
      
      // Apply scale
      const scale = {{ block.settings.model_scale | default: 1.5 }};
      mesh.scale.setScalar(scale);
      
      scene.add(mesh);
      
      // Position camera
      camera.position.z = {{ block.settings.camera_distance | default: 3 }};
      camera.position.y = {{ block.settings.camera_height | default: 0 }};
      
      console.log('üì∑ Camera positioned at:', {
        position: camera.position,
        aspect: camera.aspect
      });
      
      // Hide loading indicator
      if (loading) {
        loading.style.display = 'none';
        console.log('‚úÖ Loading indicator hidden');
      }
      
      // Start animation loop
      console.log('üé¨ Starting animation loop...');
      animate();
    });
  });
  
  // Wait for AI models to load
  function waitForAIModels(callback) {
    let tfLoaded = false;
    let depthLoaded = false;
    
    function checkLoaded() {
      if (tfLoaded && depthLoaded) {
        callback();
      }
    }
    
    // Check if TensorFlow is loaded
    if (typeof tf !== 'undefined') {
      tfLoaded = true;
      console.log('‚úÖ TensorFlow.js loaded');
    } else {
      const checkTF = setInterval(() => {
        if (typeof tf !== 'undefined') {
          tfLoaded = true;
          console.log('‚úÖ TensorFlow.js loaded');
          clearInterval(checkTF);
          checkLoaded();
        }
      }, 100);
    }
    
    // Check if depth estimation is loaded
    if (typeof depthEstimation !== 'undefined') {
      depthLoaded = true;
      console.log('‚úÖ Depth estimation loaded');
    } else {
      const checkDepth = setInterval(() => {
        if (typeof depthEstimation !== 'undefined') {
          depthLoaded = true;
          console.log('‚úÖ Depth estimation loaded');
          clearInterval(checkDepth);
          checkLoaded();
        }
      }, 100);
    }
    
    checkLoaded();
  }
  
  // Create realistic 3D object from image
  async function createRealistic3DObject(imageUrl, callback) {
    console.log('üé® Creating realistic 3D object...');
    
    try {
      // Load image
      const img = await loadImage(imageUrl);
      console.log('üì∑ Image loaded for processing');
      
      // Step 1: Remove background
      const cleanImage = await removeBackgroundAdvanced(img);
      console.log('‚úÖ Advanced background removal complete');
      
      // Step 2: Generate depth map using AI
      const depthMap = await generateDepthMap(cleanImage);
      console.log('‚úÖ AI depth map generated');
      
      // Step 3: Create 3D mesh from depth data
      const mesh = await createMeshFromDepth(cleanImage, depthMap);
      console.log('‚úÖ Realistic 3D mesh created');
      
      callback(mesh);
      
    } catch (error) {
      console.error('‚ùå Error creating realistic 3D object:', error);
      
      // Fallback to simple geometry
      console.log('üîÑ Falling back to simple 3D object...');
      const fallbackMesh = createFallback3DObject(imageUrl);
      callback(fallbackMesh);
    }
  }
  
  // Load image with promise
  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }
  
  // Advanced background removal using edge detection and AI-like processing
  async function removeBackgroundAdvanced(img) {
    console.log('ü§ñ Advanced background removal...');
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    // Advanced edge detection and segmentation
    const edges = detectEdges(imageData);
    const segments = segmentImage(imageData, edges);
    
    // Find the main object (largest connected component)
    const mainObject = findMainObject(segments);
    
    // Create mask for the main object
    for (let i = 0; i < data.length; i += 4) {
      const pixelIndex = i / 4;
      const x = pixelIndex % canvas.width;
      const y = Math.floor(pixelIndex / canvas.width);
      
      if (!mainObject.has(pixelIndex)) {
        data[i + 3] = 0; // Make background transparent
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
  }
  
  // Generate depth map using AI
  async function generateDepthMap(imageDataUrl) {
    console.log('üß† Generating AI depth map...');
    
    try {
      // Load depth estimation model
      const model = await depthEstimation.createEstimator(
        depthEstimation.SupportedModels.ARPortraitDepth
      );
      
      // Create image element from data URL
      const img = await loadImage(imageDataUrl);
      
      // Estimate depth
      const depthMap = await model.estimateDepth(img);
      console.log('‚úÖ Depth estimation complete');
      
      return depthMap;
      
    } catch (error) {
      console.log('‚ö†Ô∏è AI depth estimation failed, using procedural depth');
      
      // Fallback: procedural depth based on image content
      return generateProceduralDepth(imageDataUrl);
    }
  }
  
  // Create 3D mesh from image and depth data
  async function createMeshFromDepth(imageDataUrl, depthMap) {
    console.log('üèóÔ∏è Creating 3D mesh from depth data...');
    
    const img = await loadImage(imageDataUrl);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    
    // Create high-resolution geometry
    const width = 64; // Mesh resolution
    const height = 64;
    const geometry = new THREE.PlaneGeometry(2, 2, width - 1, height - 1);
    
    // Apply displacement from depth map
    const vertices = geometry.attributes.position.array;
    const depthData = depthMap.data || depthMap;
    
    for (let i = 0; i < vertices.length; i += 3) {
      const x = (vertices[i] + 1) * 0.5; // Convert from -1,1 to 0,1
      const y = (vertices[i + 1] + 1) * 0.5;
      
      // Sample depth value
      const depthX = Math.floor(x * (depthData.width || width));
      const depthY = Math.floor(y * (depthData.height || height));
      const depthIndex = depthY * (depthData.width || width) + depthX;
      
      // Apply depth displacement
      const depth = (depthData[depthIndex] || 0.5) - 0.5;
      vertices[i + 2] = depth * 0.3; // Z displacement
    }
    
    geometry.attributes.position.needsUpdate = true;
    geometry.computeVertexNormals();
    
    // Create realistic material
    const texture = new THREE.TextureLoader().load(imageDataUrl);
    const material = new THREE.MeshPhongMaterial({
      map: texture,
      transparent: true,
      side: THREE.DoubleSide,
      shininess: 30,
      specular: 0x111111
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    console.log('‚úÖ Realistic 3D mesh created with', vertices.length / 3, 'vertices');
    
    return mesh;
  }
  
  // Function to generate additional views (simplified - in production use AI APIs)
  function generateAdditionalViews(frontImage, callback) {
    console.log('üîÑ Generating additional product views...');
    
    // For now, create a mirrored/processed back view
    // In production, you'd call AI services like:
    // - Stability AI for view synthesis
    // - Remove.bg for better background removal
    // - Custom trained models for product view generation
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    img.onload = function() {
      canvas.width = img.width;
      canvas.height = img.height;
      
      // Create back view by flipping and darkening slightly
      ctx.scale(-1, 1);
      ctx.translate(-canvas.width, 0);
      ctx.filter = 'brightness(0.8) contrast(0.9)';
      ctx.drawImage(img, 0, 0);
      
      const backView = canvas.toDataURL();
      
      // Generate side views (simplified)
      const sideViews = generateSideViews(img);
      
      callback({
        back: backView,
        sides: sideViews
      });
    };
    img.src = frontImage;
  }
  
  // Function to create smart geometry based on product
  function createSmartGeometry(aspectRatio) {
    console.log('üèóÔ∏è Creating smart geometry...');
    const objectShape = '{{ block.settings.object_shape | default: "auto" }}';
    
    let geometry;
    
    if (objectShape === 'auto') {
      // Auto-detect based on aspect ratio
      if (aspectRatio > 1.2) {
        // Wide products - use box geometry
        geometry = new THREE.BoxGeometry(2, 2 / aspectRatio, 0.5);
        console.log('üì¶ Auto-selected: Box geometry for wide product');
      } else {
        // Tall or square products - use cylinder
        geometry = new THREE.CylinderGeometry(0.8, 0.8, 2, 16);
        console.log('üõ¢Ô∏è Auto-selected: Cylinder geometry for tall/square product');
      }
    } else if (objectShape === 'cylinder') {
      geometry = new THREE.CylinderGeometry(0.8, 0.8, 2, 16);
      console.log('üõ¢Ô∏è User-selected: Cylinder geometry');
    } else if (objectShape === 'box') {
      geometry = new THREE.BoxGeometry(2, 2 / aspectRatio, 0.5);
      console.log('üì¶ User-selected: Box geometry');
    }
    
    return geometry;
  }
  
  // Function to create materials for different faces
  function createSmartMaterials(textures) {
    console.log('üé® Creating smart materials...');
    
    return [
      new THREE.MeshLambertMaterial({ map: textures.front, transparent: true }), // front
      new THREE.MeshLambertMaterial({ map: textures.back, transparent: true }),  // back
      new THREE.MeshLambertMaterial({ map: textures.front, transparent: true }), // top
      new THREE.MeshLambertMaterial({ map: textures.front, transparent: true }), // bottom
      new THREE.MeshLambertMaterial({ map: textures.front, transparent: true }), // right
      new THREE.MeshLambertMaterial({ map: textures.front, transparent: true })  // left
    ];
  }
  
  // Helper functions for advanced image processing
  function detectEdges(imageData) {
    console.log('üîç Detecting edges...');
    const { data, width, height } = imageData;
    const edges = new Uint8Array(width * height);
    
    // Sobel edge detection
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = (y * width + x) * 4;
        
        // Get surrounding pixels
        const tl = getGrayscale(data, (y - 1) * width + (x - 1));
        const tm = getGrayscale(data, (y - 1) * width + x);
        const tr = getGrayscale(data, (y - 1) * width + (x + 1));
        const ml = getGrayscale(data, y * width + (x - 1));
        const mr = getGrayscale(data, y * width + (x + 1));
        const bl = getGrayscale(data, (y + 1) * width + (x - 1));
        const bm = getGrayscale(data, (y + 1) * width + x);
        const br = getGrayscale(data, (y + 1) * width + (x + 1));
        
        // Sobel operators
        const gx = (-1 * tl) + (1 * tr) + (-2 * ml) + (2 * mr) + (-1 * bl) + (1 * br);
        const gy = (-1 * tl) + (-2 * tm) + (-1 * tr) + (1 * bl) + (2 * bm) + (1 * br);
        
        const magnitude = Math.sqrt(gx * gx + gy * gy);
        edges[y * width + x] = magnitude > 50 ? 255 : 0;
      }
    }
    
    return edges;
  }
  
  function getGrayscale(data, index) {
    const i = index * 4;
    return (data[i] + data[i + 1] + data[i + 2]) / 3;
  }
  
  function segmentImage(imageData, edges) {
    // Simplified segmentation based on color similarity and edges
    const { data, width, height } = imageData;
    const segments = new Array(width * height).fill(0);
    let segmentId = 1;
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = y * width + x;
        if (segments[idx] === 0 && edges[idx] === 0) {
          floodFill(data, segments, x, y, width, height, segmentId++);
        }
      }
    }
    
    return segments;
  }
  
  function floodFill(data, segments, startX, startY, width, height, segmentId) {
    const stack = [[startX, startY]];
    const startColor = getPixelColor(data, startX, startY, width);
    
    while (stack.length > 0) {
      const [x, y] = stack.pop();
      const idx = y * width + x;
      
      if (x < 0 || x >= width || y < 0 || y >= height || segments[idx] !== 0) {
        continue;
      }
      
      const currentColor = getPixelColor(data, x, y, width);
      if (!colorsAreSimilar(startColor, currentColor, 30)) {
        continue;
      }
      
      segments[idx] = segmentId;
      
      stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
    }
  }
  
  function getPixelColor(data, x, y, width) {
    const idx = (y * width + x) * 4;
    return [data[idx], data[idx + 1], data[idx + 2]];
  }
  
  function colorsAreSimilar(color1, color2, threshold) {
    const diff = Math.sqrt(
      Math.pow(color1[0] - color2[0], 2) +
      Math.pow(color1[1] - color2[1], 2) +
      Math.pow(color1[2] - color2[2], 2)
    );
    return diff < threshold;
  }
  
  function findMainObject(segments) {
    // Find the largest segment (main object)
    const segmentSizes = {};
    for (let i = 0; i < segments.length; i++) {
      const seg = segments[i];
      segmentSizes[seg] = (segmentSizes[seg] || 0) + 1;
    }
    
    let largestSegment = 0;
    let largestSize = 0;
    for (const [seg, size] of Object.entries(segmentSizes)) {
      if (size > largestSize && seg !== '0') {
        largestSize = size;
        largestSegment = parseInt(seg);
      }
    }
    
    // Return set of pixels belonging to main object
    const mainObjectPixels = new Set();
    for (let i = 0; i < segments.length; i++) {
      if (segments[i] === largestSegment) {
        mainObjectPixels.add(i);
      }
    }
    
    return mainObjectPixels;
  }
  
  function generateProceduralDepth(imageDataUrl) {
    // Fallback procedural depth when AI fails
    console.log('üîß Generating procedural depth map...');
    
    return new Promise(async (resolve) => {
      const img = await loadImage(imageDataUrl);
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const { data, width, height } = imageData;
      const depthData = new Float32Array(width * height);
      
      // Generate depth based on brightness and distance from center
      const centerX = width / 2;
      const centerY = height / 2;
      const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
      
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
          const distanceFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
          const normalizedDistance = distanceFromCenter / maxDistance;
          
          // Combine brightness and distance for depth
          const depth = (brightness / 255) * (1 - normalizedDistance * 0.3);
          depthData[y * width + x] = depth;
        }
      }
      
      resolve({
        data: depthData,
        width: width,
        height: height
      });
    });
  }
  
  function createFallback3DObject(imageUrl) {
    console.log('üîÑ Creating fallback 3D object...');
    
    // Simple textured plane as fallback
    const geometry = new THREE.PlaneGeometry(2, 2);
    const texture = new THREE.TextureLoader().load(imageUrl);
    const material = new THREE.MeshLambertMaterial({
      map: texture,
      transparent: true,
      side: THREE.DoubleSide
    });
    
    return new THREE.Mesh(geometry, material);
  }
  
  // Animation loop
  let animationStarted = false;
  let clock = new THREE.Clock();
  
  function animate() {
    if (!animationStarted) {
      console.log('üé¨ Animation loop started successfully!');
      animationStarted = true;
    }
    
    requestAnimationFrame(animate);
    
    const model = window['model_{{ block.id | replace: "-", "_" }}'];
    if (model) {
      // Continuous rotation
      const rotationSpeed = {{ block.settings.rotation_speed | default: 1 }} * 0.01;
      model.rotation.y += rotationSpeed;
      
      // Optional: slight up-down bobbing
      {% if block.settings.enable_bobbing %}
        model.position.y += Math.sin(clock.getElapsedTime() * 2) * 0.01;
      {% endif %}
    }
    
    try {
      renderer.render(scene, camera);
    } catch (renderError) {
      console.error('‚ùå Render error:', renderError);
    }
  }
  
  // Handle window resize
  function handleResize() {
    console.log('üîÑ Window resize detected');
    if (!container || !camera || !renderer) {
      console.log('‚ùå Missing objects for resize');
      return;
    }
    
    const width = container.offsetWidth;
    const height = container.offsetHeight;
    
    console.log('üìè New dimensions:', { width, height });
    
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  }
  
  window.addEventListener('resize', handleResize);
  console.log('‚úÖ Resize listener added');
  
  // Handle visibility change for performance
  document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
      console.log('‚è∏Ô∏è Tab hidden - pausing animation');
      renderer.setAnimationLoop(null);
    } else {
      console.log('‚ñ∂Ô∏è Tab visible - resuming animation');
      renderer.setAnimationLoop(animate);
    }
  });
  console.log('‚úÖ Visibility change listener added');
  
  // Cleanup function
  window.addEventListener('beforeunload', function() {
    console.log('üßπ Cleaning up 3D resources...');
    if (renderer) {
      renderer.dispose();
    }
    if (model) {
      scene.remove(model);
    }
  });
  console.log('‚úÖ Cleanup listener added');
}
{% endif %}
</script>

{% schema %}
{
  "name": "Product Showcase",
  "target": "section",
  "settings": [
    {
      "type": "product",
      "id": "product",
      "label": "Select Product"
    },
    {
      "type": "header",
      "content": "3D Display Settings"
    },
    {
      "type": "checkbox",
      "id": "enable_3d",
      "label": "Enable 3D Spinning View",
      "default": false,
      "info": "Convert the product image into a spinning 3D display"
    },
    {
      "type": "range",
      "id": "rotation_speed",
      "label": "Rotation Speed",
      "min": 0,
      "max": 5,
      "step": 1,
      "default": 1,
      "info": "How fast the model rotates (0 = no rotation, 5 = fastest)"
    },
    {
      "type": "range",
      "id": "model_scale",
      "label": "Model Scale",
      "min": 0.5,
      "max": 3.0,
      "step": 0.1,
      "default": 1.5,
      "info": "Size of the 3D model"
    },
    {
      "type": "range",
      "id": "camera_distance",
      "label": "Camera Distance",
      "min": 1,
      "max": 8,
      "step": 0.5,
      "default": 3,
      "info": "How far the camera is from the model"
    },
    {
      "type": "range",
      "id": "camera_height",
      "label": "Camera Height",
      "min": -2,
      "max": 2,
      "step": 0.2,
      "default": 0,
      "info": "Vertical position of the camera"
    },
    {
      "type": "checkbox",
      "id": "enable_bobbing",
      "label": "Enable Gentle Bobbing Animation",
      "default": false,
      "info": "Adds a subtle up-down movement to the model"
    },
    {
      "type": "select",
      "id": "object_shape",
      "label": "3D Object Shape",
      "options": [
        {
          "value": "auto",
          "label": "Auto-detect (Recommended)"
        },
        {
          "value": "cylinder",
          "label": "Cylinder (Round products)"
        },
        {
          "value": "box",
          "label": "Box (Rectangular products)"
        }
      ],
      "default": "auto",
      "info": "Choose the 3D shape that best fits your product"
    },
    {
      "type": "range",
      "id": "bg_removal_sensitivity",
      "label": "Background Removal Sensitivity",
      "min": 1,
      "max": 10,
      "step": 1,
      "default": 5,
      "info": "Higher values remove more background (1=conservative, 10=aggressive)"
    },
    {
      "type": "text",
      "id": "title",
      "label": "Title",
      "default": "Featured Product"
    },
    {
      "type": "text",
      "id": "subtitle",
      "label": "Subtitle",
      "default": "Discover something amazing"
    },
    {
      "type": "textarea",
      "id": "paragraph",
      "label": "Description",
      "default": "Add your product description here. This is a great place to highlight key features and benefits that make your product special."
    },
    {
      "type": "header",
      "content": "Title Styling"
    },
    {
      "type": "range",
      "id": "title_size",
      "label": "Title Font Size",
      "min": 16,
      "max": 48,
      "step": 2,
      "default": 32,
      "unit": "px"
    },
    {
      "type": "color",
      "id": "title_color",
      "label": "Title Color",
      "default": "#000000"
    },
    {
      "type": "header",
      "content": "Subtitle Styling"
    },
    {
      "type": "range",
      "id": "subtitle_size",
      "label": "Subtitle Font Size",
      "min": 12,
      "max": 32,
      "step": 2,
      "default": 20,
      "unit": "px"
    },
    {
      "type": "color",
      "id": "subtitle_color",
      "label": "Subtitle Color",
      "default": "#666666"
    },
    {
      "type": "header",
      "content": "Text Styling"
    },
    {
      "type": "range",
      "id": "text_size",
      "label": "Text Font Size",
      "min": 12,
      "max": 24,
      "step": 1,
      "default": 16,
      "unit": "px"
    },
    {
      "type": "color",
      "id": "text_color",
      "label": "Text Color",
      "default": "#333333"
    }
  ]
}
{% endschema %}

